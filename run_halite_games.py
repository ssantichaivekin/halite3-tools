import json
import shutil
import os
import subprocess
import random
import statistics

MAP_WIDTHS = [32, 40, 48, 56, 64]

def getAverageHaliteInMap(
                gameEngineFolder,
                mapWidth,
                dumpDir,
                seed) :
    '''
    Returns a number of the average halite
    in the map generated by seed.
    '''
    gameCommand = gameEngineFolder + '/halite'
    args = [gameCommand,
            '--replay-directory', dumpDir,
            '--width' , str(mapWidth),
            '--height', str(mapWidth),
            '--results-as-json',
            '--seed', str(seed),
            '--no-compression']

    args += ['no-bot-command', 'no-bot-command']
    jsonOutputString = subprocess.check_output(args)
    jsonOutput = json.loads(jsonOutputString.decode("utf-8"))

    finalSnapshot = jsonOutput['final_snapshot']
    haliteListStr = finalSnapshot.split(';')[2]
    haliteList = haliteListStr.split(',')
    haliteList = list(filter(None, haliteList))
    # print(haliteList)
    return statistics.mean(map(int, haliteList))

def seed_selector(nSeed, mapSize, gameEngine, dumpDir) :
    '''
    Instead of playing the game with random seeds, we can play
    the game with seeds representative of the general game production
    density. This way, our graph will look cleaner.

    This function generates nSeed * 5 seeds, and return a sorted
    array of ints containing nSeed number of seeds. The replay generated
    is dumped in dumpDir. The seed selector requires the gameEngine.
    '''
    seeds = []
    randomOffset = random.randrange(100000)
    for seed in range(0, nSeed * 5) :
        avgHalite = getAverageHaliteInMap(
            gameEngineFolder=gameEngine,
            mapWidth=mapSize,
            dumpDir=dumpDir,
            seed=seed + randomOffset)
        seeds.append((seed + randomOffset, avgHalite))
    
    seeds.sort(key=lambda x: x[1])
    seeds = [seed for seed, avgHalite in seeds]
    
    representativeSeeds = []
    for i in range(nSeed) :
        chunkSize = len(seeds)//nSeed
        representativeIndex = i * chunkSize + int(chunkSize/2)
        representativeSeeds.append(seeds[representativeIndex])
    
    return representativeSeeds

def runHalite(botCallCommandList,
              gameEngineFolder,
              mapWidth = 32,
              replayDirectory = './replays',
              seed = None,
              logging = False) :
    '''
    Run halite on compiled bots.
    This command should return
    (1) the player rank, that is, a dict from player -> ranking 1,2,3
    (2) the list of the scores of players.
    '''
    numBots = len(botCallCommandList)
    assert numBots == 2 or numBots == 4, \
           "You are trying to run %d bots on a map" % numBots
    assert mapWidth in MAP_WIDTHS, 'width mismatch %s' % mapWidth
    gameCommand = gameEngineFolder + '/halite'
    args = [gameCommand,
            '--replay-directory', replayDirectory,
            '-vvv',
            '--width' , str(mapWidth),
            '--height', str(mapWidth),
            '--results-as-json',
            '--no-compression']
    if seed :
        args += ['--seed', str(seed)]
    if not logging :
        args += ['--no-logs']
    args += botCallCommandList

    jsonOutputString = subprocess.check_output(args)
    jsonOutput = json.loads(jsonOutputString.decode("utf-8"))
    return readResults(jsonOutput)

def readResults(jsonResult) :
    nPlayers = len(jsonResult['stats'].keys())
    playerRanks = [-1 for _ in range(nPlayers)]
    scoreList = []
    for player in range(nPlayers) :
        playerRank = jsonResult['stats'][str(player)]['rank']
        playerScore = jsonResult['stats'][str(player)]['score']
        playerRanks.append(playerRank)
        scoreList.append(playerScore)
    return playerRanks, scoreList

if __name__ == '__main__' :
    # We would read the json containing the run info
    with open('run_halite_config.json', 'r') as config_file :
        config = json.loads(config_file.read())
    
    n_players = 2
    n_games = config["n_games"]
    map_sizes = config["map_sizes"]
    game_engine_dir = config["game_engine_dir"]
    replay_dir = config["replay_dir"]
    bot_call_command = config["bot_call_command"]
    empty_bot_call_command = config["empty_bot_call_command"]

    # create a dump directory
    dump_dir = os.path.join(replay_dir, 'dump-temp')
    os.makedirs(dump_dir, exist_ok=True)


    for map_size in map_sizes :

        # Then, we call our seed generator to generate the
        # correct seeds for each map we want to run.
        seeds = seed_selector(nSeed=n_games, mapSize=map_size, gameEngine=game_engine_dir, dumpDir=dump_dir)

        # We are always running with just one non-trivial players.
        # Basically, we are going to run it with an empty bot.

        # Let's say we have n_games = 20, and 5 different map sizes.
        # It will run 100 non-trivial games in total.
        for seed in seeds :
            player_ranks, score_list = runHalite([bot_call_command, empty_bot_call_command],
                game_engine_dir,
                map_size,
                replay_dir,
                seed)
            print('replay mapsize = %d, seed = %d' % (map_size, seed))
            print('result =', score_list)

    # remove the dump directory
    shutil.rmtree(dump_dir)

